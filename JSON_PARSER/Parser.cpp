#include "Parser.h"

Parser::Parser(const char* source)
{
	this->source = source;

	//размер строки
	//+1 так как strlen() не учитывает \0
	size = strlen(source)+1;

	//итератор показывающий на каком индексе мы остановились. Парсинг начинаем с нуля
	currentIndex = 0ULL;
	 
	root = nullptr;
}

Parser::~Parser()
{
	//Если root не нулевой
	if (nullptr != root)
	{
		//то удаляем root? а он уже потрет все что входит внутри
		delete root;
	}
}

/*
В первую очередь сделаем проверку на nullptr и если корень пустой то создадим объект JsonNode
у root нет имени как такового поэтому мы ему присваиваем имя "root"
	Первое что мы будем парсить это наша перва нода(объект).
	У нас есть 5 типов данных и первая нода это объект, объект типа данных объект.
	Нам нужен метод отвечающий за парсинг объектов. Сначало мы должны создать объект.
	Обект мы создали и теперь мы должны его спарсить(наполнить), поэтому мы вызываем метод parseObject();
	В этот метод передаем указатель на текущий объект(текущую ноду) на объект которы мы парсим, который мы наполняем в данный момент
	*/


void Parser::parse()
{
	if (nullptr == root)
	{
		root = new JsonNode();

		root->name = "root";

		parseObject(root);
	}
}

void Parser::print() const
{
	if (nullptr != root)
	{
		//начинаем с нулевого уровня вложенности
		root->print(0);
	}
}

/*
На данном этапе мы только начали парсинг и (наша каретка) наш итератор стоит в самом начале файла там где у нас стоит "{"
Когда мы начинаем парсить, наша каретка стоит на открывающей скобочке, а это значит что наверняка знаем что это наш объект и мы можем
перейти к следующему символу.
Дальше делаем следующее, фактически нам нужен цикл, мы парсим объект границы которого от "{" до  "}".
Значит чтобы пройти по этому объекту(имеется ввиду не только глобальный(большой) объект,
а любой объект начинается с "{" и заканчивается  "}", то есть для того чтобы дойти до конца этого объекта
пока source[currentIndex] не будет равен '}'
*/
void Parser::parseObject(JsonNode* current)
{
	incrementIndex();
	/*
	Мы перешли на следующий символ после '{' и после нее есть определенное колличество символов котрые мы должны пропустить,
	символ может быть сразу же, он может быть через несколько табуляций, поэтому первое что мы делаем это goToNextSimbol();
	А дальше вспомним как устроены объекты в JSON:
	Объекты состоят из полей у которых есть имена и их значение, а значит когда мы читаем некий объект, первое на что мы должны наткнуться
	это имя следующего поля, значит здесь нужен метод считывающий string  parseString();
	Имя мы прочитали, а значит мы должны переместиться к значению и вызываем для этого goToNextSimbol();
	В этом моменте мы оказываемся в любом элементе тех типов данных, которые мы описали ранее
	Нам нужен будет еще 1 метод, который в switch будет определять на что мы наткнулись:
	объект, массив, число, строка либо это булевая переменная
	Поэтому напишем метод parseNext(); Next потому что мы не знаем, какого типа данных будет следующий объект

	*/
	while ('}' != source[currentIndex])
	{
		goToNextSimbol();

		string name = parseString();
	
		goToNextSimbol();

		parseNext(current, name);

		goToNextSimbol();
	}

	incrementIndex();
}

void Parser::parseArray(JsonNode* current)
{
	incrementIndex();

	int i = 0;

	while (']' != source[currentIndex])
	{
		
		goToNextSimbol();

		string name = to_string(i);

		++i;

		goToNextSimbol();

		parseNext(current, name);

		goToNextSimbol();
	}

	incrementIndex();

}

/*
	Фактически это простой метод. 
	В начале сделаем проверку: если мы начинае парсить объект и дошли до следующего символа, а он не является открывающимся двойнными ковычками
	значит это ошибка и мы должны вывести ошибку 
	Когда проверка прошла это значит что мы стоим на ковычках,значит чтобы начинать парсить текст мы должны сделать следующий шаг
	мы должны переступить на первую букву этой строки для этого вызовим incrementIndex();
	И здесь уже начинается наша строка, можем начать цикл до тех пор пока мы не дойдем до ковычек снова
	А вдруг внутри строки будут ковычки? Нет, не будут. Это не допускается, ковычки могут быть только в качестве другого символа, чаще всего в unicode
	Так что за это можем не бояться. Ковычки будут обоначать начало и конец нашего слова.
	Когда мы инкрементировали наш индекс и переместились на первую букву, то мы должны эту первую букву добавить к нашему слову (str += source[currentIndex];)
	Букву добавили, переходим к следующей и так до тех пор пока пока мы не наткнемся на следующийе ковычки.
	Когда мы на них натыкаемся, то делаем шаг вперед до следующего символа.
	Работа метода завершается тем что он возвращает имя считанного поля
*/
string Parser::parseString()
{ 
	if ('\"' != source[currentIndex])
		throw "unexpected symbol";

	string str;

	incrementIndex();

	while ('\"' != source[currentIndex])
	{
		str += source[currentIndex];

		incrementIndex();
	}
	//тут скорее всего мы встанем на следующий символ за ковычками, скорее всего ':'
	incrementIndex();

	return str;
}

/*
объявляем переменную типа стринг и вызываем метод parseString();
Если все пройдет нормально и не будет неожиданных символов резкого конца файла, 
то мы это value просто прочитаем как считывали имя
Дальше нужно будет определить 
Если булевое значение то = false
Если объект который равен null  то пишем null 
Только в том случае если все проверки не прошли тогда в блоке else запихиваем строку
*/


void Parser::parseString(JsonNode* current, string name)
{
	string value = parseString();

	//проверка предусматривает что true может быть написана с разным регистром
	if ("true" == value  ||  "True" == value || "TRUE" == value )
	{
		//беррем массив flags и вызываем у него метод emplace указываем имя нашего поля, которое мы парсим и значение, в данном случае true 
		current->flags.emplace(name, true);
	}

	else if ("false" == value || "False" == value || "FALSE" == value)
	{
		current->flags.emplace(name, false);
	}

	/*
	Если мы считываем слово null, значит мы понимаем о том, что у нас есть какой-то объект,
	но он = null? а значит нужно создать новую ноду и дать ей имя которое мы прочитали заранее
	установить флаг isNull = true 
	и последнее что сделать в current в objects dspdfnm метод nemplace по имени новой ноды
	внутри нее ничего не будет, так как она нулевая и ничего не содержит
	*/
	else if ("null" == value || "Null" == value || "NULL" == value)
	{
		JsonNode* node = new JsonNode();
		node->name = name;
		node->isNull = true;
		current->objects.emplace(name, node);
	}

	/*
	Когда мы прошли все проверки и убедились что это не булевая переменная, это не null 
	тогда мы просто делаем current->strings.emplase(name, value);
	*/

	else
	{
		current->strings.emplace(name, value);
	}
}
//передовать в этот метод ничего не нужно он простовернет то значение, которое найдет
/*МЫ можем считать строку, а потом преобразовать ее в значение*/
double Parser::parseNumber()
{
	string value;
	//считывать будем точно так же как считывали string
	while (source[currentIndex] != ',' && source[currentIndex] != ' ' && source[currentIndex] != ']' && source[currentIndex] != '}')
	{
		value += source[currentIndex];

		incrementIndex();
	}
	//stod - string to double
	return stod(value);
}

	/*Next потому что мы не знаем, какого типа данных будет следующий объект
	parent это текущая нода, которую мы парсим прежде чем мы вызываем метод parseNext мы спарсили строку имени (string name) 
	этого элемента, который мы будем добавлять в parent. Ну и в теле всего-то лишь switch case
	У нас есть несколько вариантов:
	Первый вариаент если у нас объект то это '{':
	
	Второй если это массив то это э'[': 
	Как парсить массивы? так как и с '{' и с '{': начинается новый обьъект, то в обоих случаях нужно создавать новую ноду
	так как массивы это такие же объекты единственноен отличие что у них нет имени у элементов
	
	третий если это строка либо булевая переменная  то это '\": 
	для этого нам нужен будет еще 1 parseString(JsonNode* parent, string name); в который мы передаем имя ноды которую мы создаем, чтобы записать ее  в массив и текущую ноду
	
	если мы условились чито true folse и null будут писаться в ковычках, тогда если мы сталкнемся с символом который не является числом
	а значит если там что то не числовое то это ошибка, значит сделаем проверку от неожиданного символа

	*/
void Parser::parseNext(JsonNode* parent, string name)
{
	switch (source[currentIndex])
	{
	case '{':
	{
		JsonNode* node = new JsonNode();

		node->name = name;
		//добавляем внов созданную ноду как наследника
		parent->objects.emplace(name, node);
		//вызовем уже созданный ранее метод parseObject, и он погрузиться на 1 уровень рекурсии и будет это делать для более глубокого уровня
		//и так до тех пор пока не исчерпаются уровни глубины
		parseObject(node);
	}break;

	case '[':
	{
		JsonNode* node = new JsonNode();
		node->isArray = true;
		parent->arrays.emplace(name, node);
		parseArray(node);
	}break;

	case '\"':
	{
		parseString(parent, name);
	}break;

	default:
	{
		double value = parseNumber();

		parent->numbers.emplace(name, value);
	}
		break;
	}
}

void Parser::assertSize()
{
	/*
	если currentIndex > size, это значит что мы вышли за пределы массива.
	В таком случае, у нас неопределенное поведение и можно вывести исключение.
	*/
	if (currentIndex > size)
	{
		throw "Index is out of bounds";
	}
}
/*
Метод инкриметирует индекс и вызывает assertSize();
это нужно делать постоянно, потому что инкремент мы будем делать часто и мы должны быть уверены что мы не вышли за пределы массива
*/
void Parser::incrementIndex()
{
	++currentIndex;

	assertSize();
}

void Parser::goToNextSimbol()
{
	//указыаваем символы которые мы должны проигнорировать
	while (' ' == source[currentIndex] || ':' == source[currentIndex] || ',' == source[currentIndex])
	{
		incrementIndex();
	}
}

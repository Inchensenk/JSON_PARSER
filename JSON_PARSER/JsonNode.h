#pragma once
#include <iostream>
#include <map>
#include <string>
using namespace std;
class JsonNode
{
public:

	~JsonNode();

	//deep - глубина текущей ноды для табуляции
	void print(int deep) const;
//private:
	/*Определим для каждого типа данных место хранения используем ассатиативный массив для хранения узлов
	Объекты object  и array, являются сложными объектами, внутри которых содержаться другие объекты.
	string, number и bool, являются простыми объектами, которые содержат лишь своё значение.
	Из веше сказанного можно сделать следующее:
	Для хранения булевых значений мы будем использовать массив flags
	Для хранения строк будем использовать массив string
	Так как javascript object notation содержит тип данных Number который включает в себя 2 типа данных целое(например int) число и число после запятой(например float), будем хранитьего в double

	В javascript любыые массивы ассоциативны, если явно не указывать ключь то по умолчанию индексы будут 0,1,2,3...

	Так как мы работаем в контексте javascript, то можно повторить реализацию в как javascript
	делаем указатель на JsonNode а в качестве ключа будет не имя а порядковый номер элемента в массиве

	Если объект сложный составной то мы будем хранить его в объектах если 
	Если массив то храним точно так же, только с препиской что это массив
	Усли это строки то мы храним их в массиве ключ значение

	Так как у нас присутсвуют указатели, нужен деструктор
	*/

	/*
    JSONE Node это составной объект, это либо объект object, либо объект array
    */  

	//у любой ноды есть имя, единственная нода без имени это корневая нода
	string name;

	//сложные составные объекты
	map<string, JsonNode*> objects;

	//массивы 
	map<string, JsonNode*> arrays;

	//строки
	map<string, string> strings;

	//числа
	map<string, double> numbers;

	map<string, bool> flags;

	bool isArray = false;

	/*Noda это объект, а так как это объект то он может быть равен nullptr*/

	bool isNull = false;

private:
	
	/*
	Каждый элемент выводится посвоему, заканчивается каким-то своим символом
	поэтомунужно написать для каждого элемента написать свой метод print

	Будем их поочередно вызывать:
	сперва вызовим стринги потом наберы потом булевые переменные потом объекты потом массивы
	
	Каждый из этих методов будет отвечать за печать собсвенного массива
	за исключением printTab который будет печатать табы
	*/


	void printStrings(int deep) const;

	void printNumbers(int deep) const;

	void printFlags(int deep) const;

	void printObjects(int deep) const;

	void printArrays(int deep) const;

	void printTab(int deep) const;
};